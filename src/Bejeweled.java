/*
 * TITLE: ICS Culminating Activity - Bejeweled
 * NAME: James Tung
 * DATE: 2024-01-15
 * DESCRIPTION: A simplified implementation of the game Bejeweled.
 */

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Scanner;

public class Bejeweled {
    /* Constants */
    static final int MAIN_MENU_CHOICE = -1;
    static final int CHAIN_REQ = 3;
    static final int NUM_MOVES = 10;
    static final int PIECE_STYLES = 8;
    static final int NUM_ROWS = 8;
    static final int NUM_COLS = 8;
    static final char EMPTY = '-';
    static final String SAVE_FOLDER = "saves\\";

    /* Globals */
    char[][] board;
    int score, moves;

    public static void main(String[] args) {
        Bejeweled game = new Bejeweled();
        game.start();
    }

    /* Helper Methods */
    /**
     * This method is used to request an integer input from the user within a specified range.
     * It prompts the user with a message and checks if the input is a valid integer within the given range.
     * If the input is "-1", it returns -1 immediately. This can be used as a special case in the program.
     * If the input is not valid or not within the range, it keeps asking until a valid input is received.
     *
     * @param prompt The message to display when asking for input.
     * @param min The minimum acceptable value for the input.
     * @param max The maximum acceptable value for the input.
     * @return The valid input received from the user.
     */
    public static int requestInt(String prompt, int min, int max) {
        Scanner sc = new Scanner(System.in);
        String input;

        do {  // Loop until valid input is received
            System.out.print(prompt);
            input = sc.next().strip();
            if (input.equals("-1")) {
                return -1;
            }
        } while (!input.matches("\\d+") || Integer.parseInt(input) < min || Integer.parseInt(input) > max);  // Check if input is an integer within range

        return Integer.parseInt(input);
    }

    /**
     * This method is used to count the number of empty cells in the game board.
     * It iterates over each cell in the board and increments a counter if the cell is empty.
     *
     * @param board The game board represented as a 2D character array.
     * @return The number of empty cells in the board.
     */
    public static int countEmpty(char[][] board) {
        int count = 0;

        for (int i = 0; i < NUM_ROWS; i++) {
            for (int j = 0; j < NUM_COLS; j++) {
                if (board[i][j] == EMPTY) {
                    count++;
                }
            }
        }

        return count;
    }

    /* Game Methods */
    /**
     * This method is used to initialize the game board.
     * It iterates over each cell in the board and assigns a random piece to it.
     * The random piece is generated by casting a random integer to a character.
     * The random integer is within the range of the number of piece styles, and 'a' is added to it to get a character.
     */
    public void initBoard() {
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLS; col++) {
                // Generate random piece
                board[row][col] = (char) ((int) (Math.random() * PIECE_STYLES) + 'a');
            }
        }
    }


    // TODO: CHANGE X TO ROW AND Y TO COL
    /**
     * This method checks if two slots on the game board are adjacent.
     * It uses the distance formula to calculate the distance between the two slots.
     * If the distance is 1, it means the slots are adjacent.
     *
     * @param x1 The x-coordinate of the first slot.
     * @param y1 The y-coordinate of the first slot.
     * @param x2 The x-coordinate of the second slot.
     * @param y2 The y-coordinate of the second slot.
     * @return True if the slots are adjacent, false otherwise.
     */
    public boolean adjSlots(int x1, int y1, int x2, int y2) {
        // Distance formula to check for adjacency
        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)) == 1;
    }

    /**
     * This method counts the number of same pieces to the left, right, up, and down of a given cell in the game board.
     * It also counts the total number of same pieces horizontally and vertically.
     * It iterates over each column and row in the board and increments a counter if the cell contains the same piece.
     * If a cell does not contain the same piece, it resets the counter.
     *
     * @param row The row index of the cell to count from.
     * @param col The column index of the cell to count from.
     * @return An array of counts. The first element is the count to the left, the second element is the count to the right,
     * the third element is the count upwards, the fourth element is the count downwards,
     * the fifth element is the total horizontal count (left + right), and the sixth element is the total vertical count (up + down).
     */
    public int[] count(int row, int col) {
        int[] counts = new int[6];  // left, right, up, down, horizontal, vertical

        // Count left/right
        for (int i = 0; i < NUM_COLS; i++) {
            if (i != col && board[row][i] == board[row][col]) {
                counts[i < col ? 0 : 1]++;  // If i < col, counting left; else, counting right
            } else {
                if (i < col) {  // If a break is found on the left, reset count
                    counts[0] = 0;
                } else if (i > col) {  // If a break is found on the right, stop counting
                    break;
                }
            }
        }

        // Count up/down
        for (int i = 0; i < NUM_ROWS; i++) {
            if (i != row && board[i][col] == board[row][col]) {
                counts[i < row ? 2 : 3]++;  // If i < row, counting up; else, counting down
            } else {
                if (i < row) {  // If a break is found above, reset count
                    counts[2] = 0;
                } else if (i > row) {  // If a break is found below, stop counting
                    break;
                }
            }
        }

        counts[4] = counts[0] + counts[1];  // horizontal
        counts[5] = counts[2] + counts[3];  // vertical

        return counts;
    }

    /**
     * This method swaps the pieces at two specified positions on the game board.
     * It first stores the piece at the first position in a temporary variable.
     * Then it sets the piece at the first position to the piece at the second position.
     * Finally, it sets the piece at the second position to the piece stored in the temporary variable.
     *
     * @param x1 The row index of the first position.
     * @param y1 The column index of the first position.
     * @param x2 The row index of the second position.
     * @param y2 The column index of the second position.
     */
    public void swap(int x1, int y1, int x2, int y2) {
        // Swap pieces
        char temp = board[x1][y1];
        board[x1][y1] = board[x2][y2];
        board[x2][y2] = temp;
    }

    /**
     * This method toggles the marking of a piece on the game board at a given position.
     * If the piece at the given position is marked (uppercase), it unmarks it by converting it to lowercase.
     * If the piece at the given position is unmarked (lowercase), it marks it by converting it to uppercase.
     *
     * @param row The row index of the piece to toggle.
     * @param col The column index of the piece to toggle.
     */
    public void toggleMark(int row, int col) {
        if (Character.isUpperCase(board[row][col])) {  // If marked, unmark
            board[row][col] = Character.toLowerCase(board[row][col]);
        } else {  // If unmarked, mark
            board[row][col] = Character.toUpperCase(board[row][col]);
        }
    }

    /**
     * This method deletes a piece on the game board at a given position by setting it to the global empty value.
     *
     * @param row The row index of the piece to delete.
     * @param col The column index of the piece to delete.
     */
    public void delete(int row, int col) {
        // Set piece to empty
        board[row][col] = EMPTY;
    }

    /**
     * This method deletes a horizontal line of pieces on the game board from a given position for a specified count.
     * It iterates over each cell in the line and sets it to the global empty value.
     * If a cell is the anchor (the piece which was swapped), it skips it and does not delete it.
     *
     * @param row The row index of the line to delete.
     * @param col The column index of the start of the line to delete.
     * @param count The number of pieces to delete from the start position.
     * @param anchor The column index of the piece to skip (the round action piece).
     */
    public void deleteHorizontal(int row, int col, int count, int anchor) {
        for (int i = col; i < col + count; i++) {
            // Skip if piece is the round action piece
            if (i != anchor) {
                board[row][i] = EMPTY;
            }
        }
    }

    /**
     * This method deletes a vertical line of pieces on the game board from a given position for a specified count.
     * It iterates over each cell in the line and sets it to the global empty value.
     * If a cell is the anchor (the piece which was swapped), it skips it and does not delete it.
     *
     * @param row The row index of the start of the line to delete.
     * @param col The column index of the line to delete.
     * @param count The number of pieces to delete from the start position.
     * @param anchor The row index of the piece to skip (the round action piece).
     */
    public void deleteVertical(int row, int col, int count, int anchor) {
        for (int i = row; i < row + count; i++) {
            // Skip if piece is the round action piece
            if (i != anchor) {
                board[i][col] = EMPTY;
            }
        }
    }

    /**
     * This method is used to update the game board after pieces have been deleted.
     * It iterates over each column from bottom to top.
     * If it finds an empty cell, it counts the number of empty cells above it (including itself) and drops the piece above the empty cells down.
     * If there are no more pieces to drop, it generates a new piece.
     */
    public void update() {
        int depth;  // Number of rows to drop

        // Delete pieces
        for (int col = 0; col < NUM_COLS; col++) {
            for (int row = NUM_ROWS - 1; row >= 0; row--) {
                if (board[row][col] == EMPTY) {
                    depth = count(row, col)[2] + 1;

                    if (row - depth >= 0) {  // If there are pieces to drop
                        board[row][col] = board[row - depth][col];
                        board[row - depth][col] = EMPTY;
                    } else {  // If no more pieces to drop; generate new piece
                        board[row][col] = (char) ((int) (Math.random() * PIECE_STYLES) + 'a');
                    }
                }
            }
        }
    }

    /**
     * This method is used to save the current state of the game to a file.
     * It first checks if the file already exists. If it does, it asks the user if they want to overwrite it.
     * If the user chooses not to overwrite, it returns false and the method ends.
     * If the file does not exist or the user chooses to overwrite, it creates the file and writes the current game board to it.
     * The game board is written to the file by calling the displayBoard method with the parameter true, which formats the board for saving.
     * If an IOException occurs during file creation or writing, it prints an error message and returns false.
     *
     * @param filename The name of the file to save to. The file will be located in the directory specified by the SAVE_FOLDER constant.
     * @return True if the game was saved successfully, false otherwise.
     */
    public boolean save(String filename) {
        Scanner sc = new Scanner(System.in);
        String path = SAVE_FOLDER + filename;
        File file = new File(path);
        BufferedWriter writer;

        if (file.exists()) {
            System.out.print("File already exists. Are you sure you want to overwrite it? (y/n)\n > ");
            if (sc.next().strip().equalsIgnoreCase("n")) return false;
        }

        try {
            file.getParentFile().mkdirs();
            file.setWritable(true);
            file.createNewFile();
            writer = new BufferedWriter(new FileWriter(file));
            writer.write(displayBoard(true));
            writer.close();

            return true;
        } catch(IOException e){
            System.out.println("Error saving file.");
            return false;
        }
    }

    /**
     * This method is used to load the game state from a file.
     * It first checks if the file exists. If it does not, it prints a message and returns false.
     * If the file exists, it opens the file and reads the score and moves from the first two lines.
     * Then it reads the game board from the rest of the file. Each piece is read as a character.
     * If an exception occurs during file reading, it prints an error message and returns false.
     *
     * @param filename The name of the file to load from. The file should be located in the directory specified by the SAVE_FOLDER constant.
     * @return True if the game was loaded successfully, false otherwise.
     */
    public boolean load(String filename) {
        // Variables
        String path = SAVE_FOLDER + filename;  // Path to file
        File file = new File(path);
        Scanner sc;

        if (file.exists()) {
            try {
                sc = new Scanner(file);
                score = sc.nextInt();
                moves = sc.nextInt();

                for (int row = 0; row < NUM_ROWS; row++) {
                    for (int col = 0; col < NUM_COLS; col++) {
                        // Get piece from save file
                        board[row][col] = sc.next().charAt(0);
                    }
                }
                sc.close();

                return true;
            } catch (Exception e) {
                System.out.println("Error loading file.");
                return false;
            }
        } else {
            System.out.println("File does not exist.");
            return false;
        }
    }

    /**
     * This method is used to display the game board.
     * It iterates over each cell in the board and adds it to a string.
     * If the output is for saving, it also adds the score and moves to the string.
     * If the output is for displaying, it also adds the row and column numbers to the string.
     *
     * @param save True if the output is for saving, false if the output is for displaying.
     * @return The formatted game board.
     */
    public String displayBoard(boolean save) {
        String output = "";  // Output string

        if (save) {
            // If output is for saving, include score and moves
            output += score + "\n";
            output += moves + "\n";
        } else {
            // If output is for displaying, include column numbers
            output += "  0 1 2 3 4 5 6 7\n";
        }

        for (int row = 0; row < NUM_ROWS; row++) {
            if (!save) {
                // If output is for displaying, include row numbers
                output += row;
            }

            for (int col = 0; col < NUM_COLS; col++) {
                output += " " + board[row][col];
            }
            output += "\n";
        }

        return output;
    }

    /**
     * This method is used to play the game.
     * It displays the game information (score, moves, board) and prompts the user for input.
     * If the user enters -1, it returns false and the method ends.
     * If the user enters valid coordinates, it swaps the pieces at the coordinates and decrements the number of moves.
     * Then it checks for chains and deletes the pieces involved in the chains, and updates the score and board.
     * If the user enters invalid coordinates, it prints a message and does not decrement the number of moves.
     * If the number of moves reaches 0, it prints a message and returns true.
     *
     * @return True if the game finished by using up all the moves, false otherwise.
     */
    public boolean play() {
        // Variables
        Scanner sc = new Scanner(System.in);
        int x1, y1, x2, y2;
        int[] c1, c2;

        while (moves > 0) {

            // Game Status
            System.out.println("Score: " + score);
            System.out.println("Remaining Moves: " + moves);
            System.out.println(displayBoard(false));

            // Get user input (1/2)
            System.out.println("Enter -1 at any time to return to the main menu.");
            if ((x1 = requestInt("Enter row 1: ", 0, NUM_ROWS - 1)) == MAIN_MENU_CHOICE) return false;
            if ((y1 = requestInt("Enter col 1: ", 0, NUM_COLS - 1)) == MAIN_MENU_CHOICE) return false;

            // Display board with marked piece
            toggleMark(x1, y1);
            System.out.println(displayBoard(false));

            // Get user input (2/2)
            System.out.println("Enter -1 at any time to return to the main menu.");
            if ((x2 = requestInt("Enter row 2: ", 0, NUM_ROWS - 1)) == MAIN_MENU_CHOICE) return false;
            if ((y2 = requestInt("Enter col 2: ", 0, NUM_COLS - 1)) == MAIN_MENU_CHOICE) return false;

            // Display board with marked piece
            toggleMark(x2, y2);
            System.out.println(displayBoard(false));

            // Wait for user to press ENTER
            System.out.println("Press ENTER to continue...");
            sc.nextLine();

            // Unmark for future equality checks
            toggleMark(x1, y1);
            toggleMark(x2, y2);

            if (!adjSlots(x1, y1, x2, y2)) {  // Check if coordinates are adjacent
                System.out.println("Coordinates are not adjacent.");
            } else {
                // Swap pieces
                swap(x1, y1, x2, y2);
                moves--;

                // Check for chains
                c1 = count(x1, y1);
                c2 = count(x2, y2);

                // Horizontal chains
                if (c1[4] + 1 >= CHAIN_REQ) {  // If horizontal chain
                    deleteHorizontal(x1, y1 - c1[0], c1[4] + 1, y1);
                }
                if (c1[5] + 1 >= CHAIN_REQ) {  // If vertical chain
                    deleteVertical(x1 - c1[2], y1, c1[5] + 1, x1);
                }

                // Vertical chains
                if (c2[4] + 1 >= CHAIN_REQ) {  // If horizontal chain
                    deleteHorizontal(x2, y2 - c2[0], c2[4] + 1, y2);
                }
                if (c2[5] + 1 >= CHAIN_REQ) {  // If vertical chain
                    deleteVertical(x2 - c2[2], y2, c2[5] + 1, x2);
                }

                // Delete action pieces
                if (c1[4] + 1 >= CHAIN_REQ || c1[5] + 1 >= CHAIN_REQ) {
                    delete(x1, y1);
                }
                if (c2[4] + 1 >= CHAIN_REQ || c2[5] + 1 >= CHAIN_REQ) {
                    delete(x2, y2);
                }

                score += countEmpty(board);  // Add points for empty spaces

                update();  // Update board
            }

        }

        // Game over
        System.out.println("No more moves remaining.");
        System.out.println("Final Score: " + score);
        System.out.println(displayBoard(false));
        System.out.println("Returning to main menu...\n");

        return true;
    }

    /**
     * This method is used to start the game.
     * It initializes the game variables and displays the main menu or in-game menu depending on the game state.
     * The main menu has options to start a new game, load a game, or exit the program.
     * The in-game menu has options to continue the current game, save the game, load a game, or exit the program.
     * If the user chooses to start a new game, it initializes the game board and starts the game.
     * If the user chooses to save the game, it prompts for a filename and saves the game to that file.
     * If the user chooses to load a game, it prompts for a filename and loads the game from that file.
     * If the user chooses to exit the program, it ends the method and the program.
     */
    public void start() {
        // Variables
        Scanner sc = new Scanner(System.in);
        int choice;
        boolean inGame = false;

        // Initialize globals
        score = 0;
        moves = NUM_MOVES;
        board = new char[NUM_ROWS][NUM_COLS];

        do {
            System.out.println("BEJEWELED");
            if (inGame) {
                // Display in-game menu options
                System.out.println("1. Continue");
                System.out.println("2. Save Game");
                System.out.println("3. Load Game");
                System.out.println("4. Exit Game");
                choice = requestInt("Enter choice: ", 1, 4);
            } else {
                // Display main menu options
                System.out.println("1. New Game");
                System.out.println("2. Load Game");
                System.out.println("3. Exit");
                choice = requestInt("Enter choice: ", 1, 3);
            }

            switch (choice) {
                case 1:
                    if (!inGame) {  // If the user enters 1 and is not in game, create a new board
                        initBoard();
                    }
                    inGame = !play();  // Play game
                    break;
                case 2:
                    System.out.print("File: ");
                    if (inGame) {  // If the user enters 2 and is in game, save the game
                        save(sc.next());
                    } else {  // If the user enters 2 and is not in game, load a game
                        load(sc.next());
                        inGame = !play();
                    }
                    break;
                case 3:
                    if (inGame) {  // If the user enters 3 and is in game, load a game
                        System.out.print("File: ");
                        load(sc.next());
                        inGame = !play();
                    } else {  // If the user enters 3 and is not in game, exit the program
                        System.out.println("Exiting game...");
                        choice = -1;
                    }
                    break;
                case 4:  // Only available when in game
                    // Exit the program
                    System.out.println("Thank you for playing!");
                    choice = -1;
                    break;
            }
        } while (choice != -1);
    }
}
